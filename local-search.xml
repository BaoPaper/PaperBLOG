<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VLC皮肤分享</title>
    <link href="/2023/07/09/VLC%E7%9A%AE%E8%82%A4%E5%88%86%E4%BA%AB/"/>
    <url>/2023/07/09/VLC%E7%9A%AE%E8%82%A4%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>改了一个开源的VLC皮肤 <a href="https://github.com/keksbaecker/papirus-vlc-theme">Papirus</a> ，简单修改了一点并加入了菜单汉化并且也在Github开源了，<a href="https://github.com/BaoPaper/VLC-Papirus-ChineseSimplified">仓库链接</a>。</p><p>汉化界面图片</p><p><img src="https://baopaper.cn/img/202307091.webp" alt="菜单汉化"></p>]]></content>
    
    
    <categories>
      
      <category>资源分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Python脚本自动部署Hexo</title>
    <link href="/2023/07/03/%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/"/>
    <url>/2023/07/03/%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/</url>
    
    <content type="html"><![CDATA[<p>博主在使用Hexo编写博客时发现每次写完新的文章后都需要手动部署博客，十分的不方便，于是请教 ChatGPT 用 Python 写了一个简单的脚本来帮我部署博客，实测运行效果很好，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-comment"># 监听的文件夹路径</span><br>posts_folder = <span class="hljs-string">&#x27;你的 Hexo 博客文章路径&#x27;</span><br><br><span class="hljs-comment"># 博客文件夹路径</span><br>hexo_folder = <span class="hljs-string">&#x27;你的 Hexo 博客路径&#x27;</span><br><br><span class="hljs-comment"># 上次检测到的文件夹状态</span><br>last_state = &#123;&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_folder_state</span>(<span class="hljs-params">folder</span>):<br>    <span class="hljs-comment"># 获取文件夹中所有文件的最后修改时间</span><br>    state = &#123;&#125;<br>    <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(folder):<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>            path = os.path.join(root, file)<br>            state[path] = os.path.getmtime(path)<br>    <span class="hljs-keyword">return</span> state<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_command</span>(<span class="hljs-params">command</span>):<br>    <span class="hljs-comment"># 执行命令</span><br>    process = subprocess.Popen(command, shell=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<br>    output, error = process.communicate()<br>    <span class="hljs-keyword">if</span> process.returncode != <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;执行命令出错：<span class="hljs-subst">&#123;error.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;执行命令成功：<span class="hljs-subst">&#123;output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    current_state = get_folder_state(posts_folder)<br>    <br>    <span class="hljs-comment"># 检查是否有文件夹变更</span><br>    <span class="hljs-keyword">if</span> current_state != last_state:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检测到文件夹变更，执行命令...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 执行hexo clean命令</span><br>        clean_command = <span class="hljs-string">&quot;cd &#123;&#125; &amp;&amp; hexo clean&quot;</span>.<span class="hljs-built_in">format</span>(hexo_folder)<br>        execute_command(clean_command)<br>        <br>        <span class="hljs-comment"># 执行hexo g命令</span><br>        generate_command = <span class="hljs-string">&quot;cd &#123;&#125; &amp;&amp; hexo g&quot;</span>.<span class="hljs-built_in">format</span>(hexo_folder)<br>        execute_command(generate_command)<br>        <br>        <span class="hljs-comment">#执行hexo d命令</span><br>        deploy_command = <span class="hljs-string">&quot;cd &#123;&#125; &amp;&amp; hexo d&quot;</span>.<span class="hljs-built_in">format</span>(hexo_folder)<br>        execute_command(deploy_command)<br><br>        last_state = current_state<br>    <br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 每隔1秒检测一次文件夹变更</span><br><br></code></pre></td></tr></table></figure><p>请注意，请将代码中的文件夹路径替换为你自己博客的实际路径。</p>]]></content>
    
    
    <categories>
      
      <category>图文教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Python</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础知识</title>
    <link href="/2023/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机的发展过程及各阶段的主要特点及分类"><a href="#计算机的发展过程及各阶段的主要特点及分类" class="headerlink" title="计算机的发展过程及各阶段的主要特点及分类"></a>计算机的发展过程及各阶段的主要特点及分类</h2><h3 id="第一代"><a href="#第一代" class="headerlink" title="第一代"></a>第一代</h3><p>电子管计算机（1946-1957）这一阶段计算机的主要特征是采用电子管元件作基本器件，用光屏管或汞延时电路作存储器，输入与输出主要采用穿孔卡片或纸带，体积大、耗电量大、速度慢、存储容量小、可靠性差、维护困难且价格昂贵。在软件上，通常使用机器语言或者汇编语言，来编写应用程序。因此这一时代的计算机主要用于科学计算。</p><p>这时的计算机的基本线路是采用电子管结构，程序从人工手编的机器指令程序，过渡到符号语言，第一代电子计算机是计算工具革命性发展的开始，它所采用的二进位制与程序存贮等基本技术思想，奠定了现代电子计算机技术基础。以冯·诺依曼为代表。</p><h3 id="第二代"><a href="#第二代" class="headerlink" title="第二代"></a>第二代</h3><p>晶体管计算机（1957-1964）20世纪50年代中期，晶体管的出现使计算机生产技术得到了根本性的发展，由晶体管代替电子管作为计算机的基础器件，用磁芯或磁鼓作存储器，在整体性能上，比第一代计算机有了很大的提高。同时程序语言也相应的出现了，如Fortran，Cobol，Algo160等计算机高级语言。晶体管计算机被用于科学计算的同时，也开始在数据处理、过程控制方面得到应用。</p><p>在20世纪50年代之前第一代，计算机都采用电子管作元件。电子管元件在运行时产生的热量太多，可靠性较差，运算速度不快，价格昂贵，体积庞大，这些都使计算机发展受到限制。于是，晶体管开始被用来作计算机的元件。晶体管不仅能实现电子管的功能，又具有尺寸小、重量轻、寿命长、效率高、发热少、功耗低等优点。使用晶体管后，电子线路的结构大大改观，制造高速电子计算机就更容易实现了。</p><h3 id="第三代"><a href="#第三代" class="headerlink" title="第三代"></a>第三代</h3><p>中小规模集成电路计算机（1964-1971）20世纪60年代中期， 随着半导体工艺的发展，成功制造了集成电路。中小规模集成电路成为计算机的主要部件，主存储器也渐渐过渡到 半导体存储器，使计算机的体积更小，大大降低了计算机计算时的功耗，由于减少了 焊点和 接插件，进一步提高了计算机的可靠性。在软件方面，有了标准化的程序设计语言和人机会话式的 Basic语言，其应用领域也进一步扩大。</p><h3 id="第四代"><a href="#第四代" class="headerlink" title="第四代"></a>第四代</h3><p>大规模和超大规模集成电路计算机（1971-2016）随着大规模集成电路的成功制作并用于计算机硬件生产过程，计算机的体积进一步缩小，性能进一步提高。集成更高的大容量半导体存储器作为内存储器，发展了并行技术和多机系统，出现了 精简指令集计算机（RISC），软件系统工程化、理论化，程序设计自动化。微型计算机在社会上的应用范围进一步扩大，几乎所有领域都能看到计算机的“身影”。</p><h3 id="第五代"><a href="#第五代" class="headerlink" title="第五代"></a>第五代</h3><p>第五代计算机指具有人工智能的新一代计算机，它具有推理、联想、判断、决策、学习等功能。</p><h2 id="我国计算机发展历程"><a href="#我国计算机发展历程" class="headerlink" title="我国计算机发展历程"></a>我国计算机发展历程</h2><h3 id="第一代电子管计算机研制（1958-1964年"><a href="#第一代电子管计算机研制（1958-1964年" class="headerlink" title="第一代电子管计算机研制（1958-1964年)"></a>第一代电子管计算机研制（1958-1964年)</h3><p>我国从1957年在中科院计算所开始研制通用数字电子计算机，1958年8月1日该机可以表演短程序运行，标志着我国第一台电子数字计算机诞生。机器在738厂开始少量生产，命名为103型计算机(即DJS-1型)。1958年5月我国开始了第一台大型通用电子数字计算机(104机)研制。在研制104机同时，夏培肃院士领导的科研小组首次自行设计并于1960年4月研制成功一台小型通用电子数字计算机107机。1964年我国第一台自行设计的大型通用数字电子管计算机119机研制成功。</p><h3 id="第二代晶体管计算机研制（1965-1972年）"><a href="#第二代晶体管计算机研制（1965-1972年）" class="headerlink" title="第二代晶体管计算机研制（1965-1972年）"></a>第二代晶体管计算机研制（1965-1972年）</h3><p>1965年中科院计算所研制成功了我国第一台大型晶体管计算机：109乙机；对109乙机加以改进，两年后又推出109丙机，在我国两弹试制中发挥了重要作用，被用户誉为“功勋机”。华北计算所先后研制成功108机、108乙机(DJS-6)、121机(DJS-21)和320机(DJS-8)，并在738厂等五家工厂生产。1965～1975年，738厂共生产320机等第二代产品380余台。哈军工(国防科大前身)于1965年2月成功推出了441B晶体管计算机并小批量生产了40多台。</p><h3 id="第三代中小规模集成电路的计算机研制（1973-80年代初）"><a href="#第三代中小规模集成电路的计算机研制（1973-80年代初）" class="headerlink" title="第三代中小规模集成电路的计算机研制（1973-80年代初）"></a>第三代中小规模集成电路的计算机研制（1973-80年代初）</h3><p>1973年，北京大学与北京有线电厂等单位合作研制成功运算速度每秒100万次的大型通用计算机，1974年清华大学等单位联合设计，研制成功DJS-130小型计算机，以后又推DJS-140小型机，形成了100系列产品。与此同时，以华北计算所为主要基地，组织全国57个单位联合进行DJS-200系列计算机设计，同时也设计开发DJS-180系列超级小型机。70年代后期，电子部32所和国防科大分别研制成功655机和151机，速度都在百万次级。进入80年代，我国高速计算机，特别是向量计算机有新的发展。</p><h3 id="第四代超大规模集成电路的计算机"><a href="#第四代超大规模集成电路的计算机" class="headerlink" title="第四代超大规模集成电路的计算机"></a>第四代超大规模集成电路的计算机</h3><p>研制和国外一样 ，我国第四代计算机研制也是从微机开始的。1980年初我国不少单位也开始采用Z80，X86和6502芯片研制微机。1983年12电子部六所研制成功与IBM PC机兼容的DJS-0520微机。10多年来我国微机产业走过了一段不平凡道路，以联想微机为代表的国产微机已占领一大半国内市场。</p><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><h3 id="根据功能分类"><a href="#根据功能分类" class="headerlink" title="根据功能分类"></a>根据功能分类</h3><p>个人计算机（PC）：主要用于个人办公、学习和娱乐等方面的计算机。<br>工作站：专门为专业计算或科学应用而设计的计算机，它通常具有高性能、高可靠性和高扩展性。<br>服务器：主要用于提供网络服务和存储数据的计算机。<br>超级计算机：主要用于处理大规模科学计算和数据分析等高性能计算领域的计算机。</p><h3 id="根据体积和尺寸分类"><a href="#根据体积和尺寸分类" class="headerlink" title="根据体积和尺寸分类"></a>根据体积和尺寸分类</h3><p>超级计算机：通常需要占用大量的物理空间。<br>服务器：通常较大，需要安装在专门的机架中。<br>笔记本电脑：便携性强，体积小。<br>平板电脑：更加轻便，可以随时携带。<br>台式电脑：通常占用一定的物理空间，需要桌面等支撑。</p><h3 id="根据处理器架构分类"><a href="#根据处理器架构分类" class="headerlink" title="根据处理器架构分类"></a>根据处理器架构分类</h3><blockquote><p>为什么没有x64架构计算机？</p><p>由于x64架构是x86架构的扩展，因此通常将其视为x86架构的一种变体，而不是单独的一种架构。因此，在一些分类中，将x64架构计算机视为x86架构计算机的一个子类，而不是独立的架构。</p></blockquote><p>x86架构计算机：常见于个人计算机和服务器。<br>ARM架构计算机：常见于移动设备、嵌入式系统和服务器。</p><h3 id="根据使用场景分类"><a href="#根据使用场景分类" class="headerlink" title="根据使用场景分类"></a>根据使用场景分类</h3><p>嵌入式系统：通常用于嵌入到其他设备中，如智能家居、汽车、工业自动化等。<br>移动设备：如智能手机、平板电脑、便携式游戏机等。<br>游戏机：如主机游戏机、掌机等。<br>个人电脑：如笔记本电脑、台式电脑等。<br>服务器：用于提供网络服务和存储数据等。<br>超级计算机：主要用于高性能计算和数据分析等领域。</p><h3 id="根据操作系统分类"><a href="#根据操作系统分类" class="headerlink" title="根据操作系统分类"></a>根据操作系统分类</h3><p>Windows计算机：使用Microsoft Windows操作系统。<br>MacOS计算机：使用苹果公司开发的MacOS操作系统。<br>Linux计算机：使用Linux操作系统。<br>Android设备：使用Android操作系统。<br>iOS设备：使用iOS操作系统。</p><h2 id="进制的概念及换算"><a href="#进制的概念及换算" class="headerlink" title="进制的概念及换算"></a>进制的概念及换算</h2><h3 id="进制的概念"><a href="#进制的概念" class="headerlink" title="进制的概念"></a>进制的概念</h3><p>N进制采用“逢N进1”的进位规则<br>计算机内部采用二进制的主要原因：易于实现、运算简单、通用性强、可靠性高<br>进制的三要素：数位、基数、位权<br>二进制B 八进制O 十进制D 十六进制H</p><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><h4 id="二进制的逻辑运算"><a href="#二进制的逻辑运算" class="headerlink" title="二进制的逻辑运算"></a>二进制的逻辑运算</h4><p>逻辑非运算&#x2F;取反运算  取反<br>逻辑与运算&#x2F;逻辑乘∩&#x2F;·  全一为一<br>逻辑或运算&#x2F;逻辑加∪&#x2F;+  见一得一<br>逻辑异或运算&#x2F;按位加⊕  同0异1<br>逻辑同或运算⊙  同1异0</p><h4 id="数制的转换"><a href="#数制的转换" class="headerlink" title="数制的转换"></a>数制的转换</h4><p>基数为R的数字，将R进制数用按权展开求和法转换成十进制数<br>十进制转换为十六进制，整数除以16取余</p><h3 id="数据在计算机中的处理过程"><a href="#数据在计算机中的处理过程" class="headerlink" title="数据在计算机中的处理过程"></a>数据在计算机中的处理过程</h3><h4 id="通常可以分为四个步骤：输入、处理、输出和储存。下面是每个步骤的具体描述："><a href="#通常可以分为四个步骤：输入、处理、输出和储存。下面是每个步骤的具体描述：" class="headerlink" title="通常可以分为四个步骤：输入、处理、输出和储存。下面是每个步骤的具体描述："></a>通常可以分为四个步骤：输入、处理、输出和储存。下面是每个步骤的具体描述：</h4><ol><li>输入：将外部数据（例如文本、图像、音频等）输入到计算机中，通常使用各种输入设备，如键盘、鼠标、摄像头、麦克风等。</li><li>处理：计算机对输入的数据进行处理，通常使用中央处理器（CPU）执行各种算法和指令。处理过程包括读取、存储、转换和计算等操作，最终将数据转化为所需的结果。</li><li>输出：将处理后的数据输出到外部设备，如显示器、打印机、扬声器等。输出的数据可以是文本、图像、音频或视频等形式。</li><li>储存：计算机将数据存储在内存或硬盘等存储介质中，以便在需要时可以快速访问。计算机使用二进制数（0和1）表示数据，并将其储存在存储介质中。</li></ol><h4 id="在计算机中，数据可以以多种不同的方式储存，最常见的储存方式包括："><a href="#在计算机中，数据可以以多种不同的方式储存，最常见的储存方式包括：" class="headerlink" title="在计算机中，数据可以以多种不同的方式储存，最常见的储存方式包括："></a>在计算机中，数据可以以多种不同的方式储存，最常见的储存方式包括：</h4><ol><li><p>内存储存：内存是计算机中用于暂时存储数据的一种储存介质。计算机将数据存储在内存中以便更快地访问和处理。</p></li><li><p>硬盘储存：硬盘是计算机中用于永久存储数据的一种储存介质。硬盘可以存储大量的数据，并且数据可以长时间保持在硬盘上。</p></li><li><p>光盘和闪存储存：光盘和闪存是另外两种常见的储存介质。光盘可以用于存储大量的数据，如音频、视频和软件程序等。闪存储存器通常用于存储相对较小的数据，如文档、照片和音乐等。</p></li><li><p>云存储：云存储是一种通过网络连接到远程服务器来存储和访问数据的方式。云存储可以提供高度的可靠性和安全性，并且可以随时随地从任何设备访问数据。</p></li></ol><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>西文字符编码：ASCII码是一种用7位二进制表示1个字符的字符编码，共可以表示128个不同字符，由32个控制字符、10个十进制数码、52个大小写英文字母、34个专业符号组成，字符在计算机中实际用一个字节8个二进制位表示<br>汉字编码<br>汉字信息交换码（交换码）也叫国标码：4位16进制数。包含一级常用字3755个，二级常用字3008个<br>汉字输入码（外码）：流行的编码方案有全拼输入法、双拼输入法、自然码输入法和五笔输入法等<br>汉字内部码（机内码）:计算机内部对汉字进行存储、处理的汉字代码<br>汉字字形码&#x2F;字模&#x2F;汉字输出码：表示汉字字形信息的编码，用来实现汉字的输出，字形码最常见的表示方式是点阵形式<br>区位码：四位十进制数，前两位叫做区码，后两位叫做位码<br>汉字国标码&#x3D;汉字区位码（区、位均要转换成十六进制）+2020H<br>汉字内部码&#x3D;汉字国标码+8080H</p><h2 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h2><p>计算机系统通常由以下几个组成部分组成：</p><ol><li>中央处理器（CPU）：它是计算机系统的核心，负责执行计算机程序中的指令。CPU通常包括算术逻辑单元（ALU）、控制单元（CU）和寄存器。</li><li>存储器：存储器是计算机系统中用于存储数据和指令的部件。存储器通常被划分为两类：主存储器和辅助存储器。主存储器（例如，随机存取存储器（RAM））用于存储程序和数据，而辅助存储器（例如，硬盘、光盘和闪存驱动器）则用于长期存储数据。</li><li>输入&#x2F;输出设备（I&#x2F;O设备）：输入&#x2F;输出设备用于与计算机系统的用户或其他外部设备进行通信。例如，键盘、鼠标和显示器用于输入和输出文本和图像，打印机用于输出文档。</li><li>系统总线：系统总线是计算机系统中各个组件之间通信的物理通道。它可以传输指令、数据和控制信号，以便各个组件协同工作。</li></ol><p>除了上述组成部分，还有其他一些部件和技术，例如网络接口卡、操作系统、编程语言和应用软件。这些部件和技术对于构建和使用计算机系统都是至关重要的。</p><h3 id="计算机软件系统主要由以下几个组成部分："><a href="#计算机软件系统主要由以下几个组成部分：" class="headerlink" title="计算机软件系统主要由以下几个组成部分："></a>计算机软件系统主要由以下几个组成部分：</h3><ol><li>应用程序：应用程序是计算机软件系统的核心组成部分，它们是为了实现特定的功能或解决特定问题而设计和开发的。应用程序可以包括单个程序或多个程序的组合，可以是基于命令行或图形用户界面（GUI）的。</li><li>操作系统：操作系统是计算机软件系统的核心组成部分之一，它是管理计算机硬件和软件资源的系统软件。操作系统包括了各种功能，如内存管理、进程管理、文件系统管理、设备管理、网络管理等。</li><li>数据库系统：数据库系统是一种用于管理和存储大量数据的软件系统，它包括数据库管理系统（DBMS）和一些数据库应用程序。数据库系统提供了一个结构化的、可靠的数据存储机制，能够支持数据的快速存储、检索和更新。</li><li>网络软件：网络软件是计算机软件系统的一个重要组成部分，它包括各种网络协议、网络应用程序、网络安全软件等。网络软件可以让计算机之间进行通信、共享资源和数据。</li><li>编程语言和开发工具：编程语言和开发工具是计算机软件系统的基础组成部分，它们用于开发和维护各种软件应用程序。编程语言包括了各种高级语言和低级语言，开发工具包括了各种集成开发环境（IDE）和调试器。</li></ol><p>将上述计算机软件系统组成按照系统软件和应用软件进行分类如下：</p><p>系统软件：</p><ol><li>操作系统</li><li>数据库系统</li><li>网络软件</li><li>编程语言和开发工具</li></ol><p>应用软件：</p><ol><li>应用程序</li></ol><h3 id="如何区分系统软件和应用软件"><a href="#如何区分系统软件和应用软件" class="headerlink" title="如何区分系统软件和应用软件"></a>如何区分系统软件和应用软件</h3><p>系统软件是计算机软件系统中的基础组成部分，它们提供了管理计算机硬件和软件资源的各种功能。应用软件是在系统软件的基础上构建的，用于实现特定功能或解决特定问题的程序。操作系统、数据库系统、网络软件和编程语言和开发工具都是系统软件；而应用程序是应用软件的代表。</p><p>系统软件和应用软件可以根据其作用和功能进行分类。</p><p>系统软件是计算机系统中的基础软件，负责管理和控制硬件和其他软件资源。它们通常不直接与用户交互，而是提供基础功能和服务来支持应用程序的运行。系统软件可以进一步细分为以下几类：</p><ol><li>操作系统：负责管理计算机的硬件资源和软件资源，为应用程序提供运行环境和接口。</li><li>驱动程序：提供硬件设备的控制程序，与操作系统协同工作以实现硬件设备的正常使用。</li><li>网络软件：管理计算机网络的通信协议和服务，为应用程序提供网络通信功能。</li><li>安全软件：包括防火墙、杀毒软件等，提供保护计算机系统和数据安全的功能。</li></ol><p>应用软件则是指具有特定功能和应用的软件程序。它们被设计和开发用于完成特定任务，如写作、游戏、多媒体处理、图像处理、财务管理等。应用软件可以进一步细分为以下几类：</p><ol><li>办公软件：如文字处理、电子表格、演示文稿等，用于办公和处理文档、表格、图表等。</li><li>多媒体软件：如音频和视频播放器、图像处理软件等，用于处理和播放多媒体文件。</li><li>游戏软件：如电脑游戏、手机游戏等，用于娱乐和休闲。</li><li>工程软件：如CAD、CAM等，用于工程设计和制造。</li><li>教育软件：如在线学习平台、电子课本等，用于教育和学习。</li></ol><p>总的来说，系统软件是为应用软件提供基础支持和服务的软件，而应用软件则是为完成特定任务和解决特定问题而设计和开发的软件。</p><h2 id="操作系统的基本概念和分类"><a href="#操作系统的基本概念和分类" class="headerlink" title="操作系统的基本概念和分类"></a>操作系统的基本概念和分类</h2><p>计算机操作系统可以分成以下几种：</p><ol><li>批处理操作系统：这种操作系统可以自动处理大量的批量作业，采用作业控制语言（Job Control Language，JCL）来描述作业，通过作业调度程序将多个作业按照一定的顺序提交给计算机系统处理。</li><li>分时操作系统：这种操作系统可以同时为多个用户提供服务，允许多个程序同时运行。这种系统采用了分时技术，将计算机时间分割成多个时间片，每个用户都可以在自己的时间片内独占计算机资源。例如UNIX就是一种分时操作系统。</li><li>实时操作系统：这种操作系统可以在规定的时间内对输入做出快速响应，通常用于控制和监控等领域。例如航空交通管制系统、医疗设备等就是实时操作系统的应用。</li><li>分布式操作系统：这种操作系统可以通过网络连接多个计算机，实现资源共享和协同工作。这种系统通常采用分布式技术，允许多个计算机共同完成一个任务。例如云计算、物联网等就是分布式操作系统的应用。</li><li>实时分布式操作系统：这种操作系统结合了实时和分布式操作系统的特点，可以在规定的时间内对输入做出快速响应，同时通过网络连接多个计算机，实现资源共享和协同工作。这种系统通常用于控制和监控等领域的应用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>电脑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手机快充是如何实现的</title>
    <link href="/2021/08/09/%E6%89%8B%E6%9C%BA%E5%BF%AB%E5%85%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <url>/2021/08/09/%E6%89%8B%E6%9C%BA%E5%BF%AB%E5%85%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="手机快充是是怎样实现的？"><a href="#手机快充是是怎样实现的？" class="headerlink" title="手机快充是是怎样实现的？"></a>手机快充是是怎样实现的？</h1><p>随着智能手机的高速发展，处理器的性能越来越强悍，在手机上游玩画质一流的大型游戏也不再是梦想。</p><p><img src="https://baopaper.cn/img/202307022.webp" alt="原神"></p><p>但是，性能强悍的处理器虽然给我们带来了流畅的游戏体验，但是缺点也非常明显，那就是功耗也比较高，一般的手机游玩大型游戏4、5个小时就歇菜了，在电池技术尚未获得突破的今天，技术人员是如何曲线救国解决续航短板的问题的呢？没错，就是那句熟悉的台词。</p><blockquote><p>充电五分钟，通话两小时</p></blockquote><p>这就是快充</p><h2 id="快充的发展"><a href="#快充的发展" class="headerlink" title="快充的发展"></a>快充的发展</h2><p>我们都知道，P &#x3D; U × I ，想要提高充电功率，可以提高电压或者电流。也就演变成了快充发展的三个大趋势：</p><blockquote><p>提高电压，高压快充方案；<br>加大电流，低压大电流方案；<br>我全都要 . jpg——电荷泵。</p></blockquote><p>那么现在就让我们回顾一下最开始的快充技术是怎样的吧</p><hr><p>2010年，为了提高USB-IF的充电功率，规范并提出了BC1.2充电协议，最高功率支持到7.5w，嗯，比苹果的5v1a快（</p><p>到了2012年7月，USB-IF发布了PD1.0快充协议，在当时提出了在USB3.0和USB2.0接口上传输最大100w的美好设想。可是受限于当时设备的兼容性和Micro-USB接口的信号不完整，最终没有实现，导致用户感知不强。</p><p>2013年，我们熟悉的高通发布了它的第一代快充协议，QC1.0，高通通过修改引脚，增加通信协议来识别快充，从而解决了新老设备的兼容性，使得电流达到Micro-USB接口的最大电流-2A，从而达到10w的功率，相比于传统的BC-1.2协议整整提升了40%。</p><p>2014年8月，USB-IF发布了两个具有革命性意义的产品，分别是PD2.0标准和Type-C接口，其中Type-C接口支持正反盲插，引脚数量大大提升，为未来的各种数据传输提供了足够的冗余。</p><p><img src="https://baopaper.cn/img/202307023.webp" alt="Type-C接口"></p><p>而PD2.0协议充分利用了Type-C接口丰富的引脚，让它不仅能传输基本的电流和数据，还能输出音视频，而且速度还大大增加。做个比较，与Micro-USB相比，Type-C接口最大支持到20V5A即100w的功率，比垃圾Micro-USB不知道高到哪里去了。</p><p>2014年底，高通QC2.0发布。高通考虑到那时Type-C接口并未普及，市面上最多的接口是Micro-USB，高通的技术人员想到了一个在接口电流无法增加的情况下提升功率的方法，那就是提升输出电压，于是高通的QC2.0将充电器输出电压增加到了9V，最高支持到18W的功率。这就是前面提到的高压充电方案的雏形。</p><p>但是这种高压低流的充电方案也有着很明显的缺点，那就是手机发热大，因为手机电池无法直接接受来自充电器的9V电压，所以高压会在手机内部被降到适合锂电池的5V电压，而这个转换过程就会产生损耗，大概10%的功率会在损耗中变成热能，导致手机发热严重，几乎无法实现亮屏快充。</p><p>之后的QC3.0到QC4+快充协议，主要是朝着兼容性和安全性走的，成为了市面上普及率比较高的充电协议。</p><hr><p>时间回到2017年左右，那是国内很多手机仍然还是垃圾的Micro-USB接口，传输电流的能力非常有限，但这可难不住我们的国产品牌-OPPO，OPPO通过魔改接口的方法在Micro-USB接口中增加了2个专门用来传输电力的引脚，让Micro-USB传统的5Pin接口变成了7Pin，大大的增加了接口的电流传输能力，最大可以传输4A电流。此后OPPO通过自己的VOOC快充协议在市面上宣传“充电五分钟，通话两小时”，在国内市场上掀起了一波高潮，让那时的人们认识到手机充电居然能这么快。</p><p>在此之后，联发科也推出了自己的快充协议-PEP，典型功率是12V 2A也就是24W，和高通的QC2.0快充一样，也是高压低流方案，通过加大电压来实现高功率充电。以及魅族早期的mCharge 1.0-4.0也就是基于联发科的PE协议，直到2016年底魅族和高通的和解，才兼容了主流的QC和PD快充协议。</p><hr><p>在此之后，Type-C接口逐渐走进了大众，快充终于不用受限高压低流了，各个厂商都推出了自己的快充协议，如华为的SCP、FCP，OPPO的SuperVOOC、一加的Dash闪充、魅族的mCharge等等。</p><p>但是这么多的快充协议，导致的缺点也是很明显的，一个充电头只支持自己的协议，对支持的手机就能快充，不支持的话用户就只能忍受慢充的漫长充电时间了。于是在2017年2月，USB-IF组织更新了USB-PD3.0的标准，带来了可编程电源PPS，让一个充电设备支持多个充电协议，无论你是什么手机都能成功握手协议开始快充。PPS规范让充电设备的电压调幅细化到了20mV一档，电压调节更为精准。同时规定3A以上的数据线必须配备E-Marker芯片，简化传输协议、充电协议的握手程序，让握手更快，成功率更高。</p><p>上面讲了高压低流和低压高流，这两种方案都有各自的优缺点，比如低压高流对充电线要求比较高，需要购买专用的大电流数据线才能快充，那么如何兼顾低压和高压从、快充的优点呢？华为发布的SCP快充协议就完美的兼顾了上面两者的优点，SCP协议，采用10V4A电荷泵高压直冲技术，这个电荷泵是存在于手机里的降压部件，它能在损耗非常小的情况下将输入电压减半，将普通的90%转换率提高到了惊人的98%~99%左右，使得高压快充也不怎么发热。</p><p>同时，另一边的快充大厂OPPO也推出了自己的快充新技术，在手机内部做两块电芯，让两块电芯并联在一起，两块电芯同时充电，大大的提升了充电速度和充电效率。</p><p>之后各大手机厂商更是将充电功率提高到了100w甚至更高，使得手机充电不再有漫长的等待，起床后插入电源，洗脸刷牙吃个早餐的时间手机就充满了，简直不要太爽。</p><p>看完厉害的快充，让我们看一个熟悉的品牌，看看它对快充有什么特殊的见解吧。</p><h1 id="苹果，快充发展中的一股泥石流"><a href="#苹果，快充发展中的一股泥石流" class="headerlink" title="苹果，快充发展中的一股泥石流"></a>苹果，快充发展中的一股泥石流</h1><p>苹果我们最早知道的快充是Apple2.4A快充，苹果的Ipad赠送的充电器就支持这个快充协议，最大功率为12W，到了IPhone8之后便支持了PD快充协议，可是苹果和其他品牌不一样，它虽然支持快充，可是苹果不在手机包装附赠快充头，而一直都只给个5V1A的安全充电头（</p><p>并且官网上售卖的快充套装更是价格高得离谱，并且定价更是让人怀疑苹果公司的相关人员脑袋是不是让门夹了（</p><p>其中5W电源售价145￥，而20W电源售价149￥</p><p>？？？</p><p>而一根与之配套的USB-C转闪电数据线售价145￥，嗯，有钱人的钱真好赚（</p><p>并且第三方的配件想要支持苹果的快充就需要向苹果申请授权，那就是MFi认证，这个授权本意上是为了用户的充电安全，但极高的授权费用就一言难尽了。</p><h1 id="快充究竟会不会伤害电池寿命呢？"><a href="#快充究竟会不会伤害电池寿命呢？" class="headerlink" title="快充究竟会不会伤害电池寿命呢？"></a>快充究竟会不会伤害电池寿命呢？</h1><p>这个问题不用说，肯定是会的，但其实不管是5W的安全快充还是100W的超级快充都是会减少电池寿命的，换句话说就是：人生这么短暂，让快充给你节约一点时间吧。手机是用来用的，不是用来当宝贝一样护着的，只要我们正常使用手机，都是没有关系的。</p><hr><p>本文参考了多方资料，并经作者个人加入补充说明。</p>]]></content>
    
    
    <categories>
      
      <category>闲聊杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MC基岩版服务器开服指南</title>
    <link href="/2021/06/06/MC%E5%9F%BA%E5%B2%A9%E7%89%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8D%97/"/>
    <url>/2021/06/06/MC%E5%9F%BA%E5%B2%A9%E7%89%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MC基岩版开服教程"><a href="#MC基岩版开服教程" class="headerlink" title="MC基岩版开服教程"></a>MC基岩版开服教程</h1><p>首先在教程之前我们需要准备<strong>以下东西</strong></p><ul><li>一个正常的、有足够判断能力、有耐心的人</li><li>有足够的经济支持</li><li>一台手机（如果有电脑那更好）</li></ul><p>如果你准备好了，那么往下滑，教程正式开始。</p><h2 id="1-什么是服务器？"><a href="#1-什么是服务器？" class="headerlink" title="1.什么是服务器？"></a>1.什么是服务器？</h2><p>Minecraft服务器（Minecraft Server）可以使玩家在线和其他玩家一起玩Minecraft。</p><h3 id="服务器的种类"><a href="#服务器的种类" class="headerlink" title="服务器的种类"></a>服务器的种类</h3><p>目前有多种服务器以独特的游戏内容、规则以及引入的社会结构而闻名。没有任何两个服务器是完全相同的，服务器类型之间的界线通常是模糊的无法区分的。许多特殊种类的服务器使用地图编辑器或在创造模式中来建造自定义地图，使用CraftBukkit软件来提供附加功能。这些服务器多数面向PVP，还有一些面向生存模式、创造模式和极限模式的，一些服务器拥有经济系统，一些服务器有内置迷你游戏。<br>那么，如何架设自己的我的世界服务器呢？让我们一起进入教程下一阶段。</p><h2 id="2-如何架设服务器？"><a href="#2-如何架设服务器？" class="headerlink" title="2.如何架设服务器？"></a>2.如何架设服务器？</h2><p>有许多工具提供给玩家以便玩家能够架设、运行和管理一个服务器。注意，服务器有服务器需求以便服务器能够高效流畅地运行。</p><p>官方多人游戏服务端可从Mojang处免费下载和使用，Windows、macOS以及基于Unix的系统（Linux、BSD…）可用。详见Minecraft多人游戏服务器教程以及Mojang的Minecraft 多人游戏服务器下载页面以获取帮助。</p><ul><li><strong>向局域网开放</strong>提供一个在未在路由器设定转发的情况下与你同一本地网络的玩家可访问的服务器。详见搭建局域网服务器教程来获取更多信息。</li><li><strong>第三方的服务端</strong>如Bukkit、Spigot和Sponge为玩家提供一种向服务器添加插件的方法。这些服务端通常用在较大的服务器上，他们可以运行插件来防止恶意破坏、提供额外的玩法和获得比默认多人游戏服务端更强的多核性能。</li><li><strong>租用服务器</strong>是由其他公司外部托管的服务器。这些托管服务器并不是免费使用的，玩家必须定期支付服务器租金。</li><li><strong>Realms</strong>是Mojang官方托管服务器服务，允许一定数量的玩家在服务器游玩。</li></ul><p>在此教程里，我们主要介绍如何租用服务器并在服务器上架设自己的我的世界服务器。</p><p>ps：这一句话可能有些绕，你需要弄懂租用的服务器和我的世界服务器之间的关系和区别，可以理解为租用的服务器就是一台电脑，在这台电脑上运行我的世界服务端，那么便把这个服务器叫做我的世界服务器。</p><p>此教程服务器提供商为<strong>腾讯云</strong>，当然你也可以选用其他的提供商，比如<strong>阿里云</strong>、<strong>百度云</strong>。</p><hr><h3 id="如何租用服务器"><a href="#如何租用服务器" class="headerlink" title="如何租用服务器"></a>如何租用服务器</h3><p>打开服务器提供商官网，注册一个账号然后完成实名注册，详细的步骤就不说了，可以自己探索一下</p><p>在腾讯云官网中打开云服务器选购，即可看到如下画面。</p><p><img src="https://baopaper.cn/img/202307021.webp" alt="服务器价格"></p><p>可能有些小伙伴看到这个价格就有点害怕了，不用怕，其实图中所选配置适合中大型服务器，我们开一些小型生存服务器是不用这么多钱的，实测5人小型服务器只需1m带宽单核1g内存的服务器就能跑起来。</p><p>并且腾讯云有一个活动，可以用很便宜的价格购买一年的服务器，<a href="https://cloud.tencent.com/act/new?from=14034">点我即可打开</a></p><p>在活动中有一个99元一年的服务器，如果你只想开一个小型生存服务器，那么我推荐你购买这个。<br>ps：在服务器购买菜单中将系统选择为<strong>Windows Server2016</strong>记好服务器的IP地址和自己设的管理密码。</p><p>购买完毕后我们在<strong>控制台</strong>中就可以看到我们的服务器了。</p><p>请开放端口为 <strong>UDP协议的19132</strong> 端口，基岩版需要其进行通信(<strong>列如阿里云、腾讯云需去安全组进行开放端口</strong>)</p><hr><h3 id="在服务器上的具体操作"><a href="#在服务器上的具体操作" class="headerlink" title="在服务器上的具体操作"></a>在服务器上的具体操作</h3><p>如果你使用的是手机，那么我们下载<strong>RD Client</strong>这个微软官方的远程管理软件，如果你使用的是电脑，那么我们可以按下win徽标搜索<strong>远程桌面</strong>即可。</p><p>进入软件，输入服务器IP、用户名以及密码，用户名默认是<strong>Administrator</strong>，输入完成进入远程桌面。</p><p>正常进入后，你会发现这不就是一台电脑吗？不管是壁纸、桌面上的软件都和我们平常看到的电脑一模一样，这就是我们前面说的<strong>服务器就是一台电脑</strong>。</p><p>我们打开服务器上的浏览器，如果没有就用IE下一个( IE太垃圾所以不把它看做是浏览器XD)。</p><p>打开<a href="https://www.minecraft.net/en-us/download/server/bedrock/">我的世界服务端官网</a>，在里面选择下载适用于Windows的服务端文件，下载完成后解压到合适的地方，解压完成后我们会看到这些文件</p><ul><li><p>behavior_packs</p></li><li><p>definitions</p></li><li><p>resource_packs</p></li><li><p>structures</p></li><li><p>bedrock_server.exe</p></li><li><p>bedrock_server.pdb</p></li><li><p>bedrock_server_how_to.html</p></li><li><p>permissions.json</p></li><li><p>release-notes.txt</p></li><li><p>server.properties</p></li><li><p>whitelist.json</p></li></ul><p>看到这么多文件，你可能会头疼“这么多文件，怎么弄？？“，不用担心，我们只需要对其中几个文件进行修改即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>服务端解压后会包含一个名为<code>server.properties</code> 的配置文件，服务相关的配置就在这个配置文件中。</p><p>可以用 nano 编辑器打开配置文件编辑。</p><p>配置文件中的 <code>#</code> 开头的行是注释，可以不用管，主要就是修改 <code>=</code> 后面的内容。</p><p>下面是一些配置项说明：</p><ul><li><p><code>gamemode</code>：默认的游戏模式，<code>survival</code> 生存，<code>creative</code> 创造，<code>adventure</code> 冒险。</p></li><li><p><code>difficulty</code>：默认难度，<code>peaceful</code> 和平，<code>easy</code> 简单，<code>normal</code> 普通，<code>hard</code> 困难。</p></li><li><p><code>max-players</code>：玩家数量限制，默认为 <code>10</code>。</p></li><li><p><code>server-port</code>：服务器端口，默认为 <code>19132</code>。</p></li><li><p><code>server-portv6</code>：IPv6 端口，默认为 <code>19133</code>。</p></li><li><p><code>online-mode</code>：正版验证，如果你的服务器可以正常连接到 Xbox Live 的话，可以设置为 <code>true</code>，否则可以设置为 <code>false</code>，即便不开启正版验证，客户端也需要登录 Xbox Live 才能联机。</p></li><li><p><code>white-list</code>：白名单，只有在白名单中的玩家才能进入服务器，默认为 <code>false</code>。</p></li><li><p><code>allow-cheats</code>：允许作弊，默认为 <code>false</code>。</p></li><li><p><code>player-idle-timeout</code>：自动踢出挂机玩家，默认为 30 分钟。</p></li><li><p><code>default-player-permission-level</code>：默认玩家等级，<code>visitor</code> 游客，<code>member</code> 普通玩家，<code>operator</code> 管理员。</p></li></ul><h2 id="白名单配置"><a href="#白名单配置" class="headerlink" title="白名单配置"></a>白名单配置</h2><p>服务端解压后会包含一个 <code>whitelist.json</code>文件，这就是储存白名单的文件，格式如下：</p><pre><code class="hljs"><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;name1&quot;</span>,<br>        <span class="hljs-string">&quot;ignoresPlayerLimit&quot;</span>: <span class="hljs-string">&quot;true&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;name2&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure></code></pre><p>其中的 <code>name</code> 是玩家的 Xbox 用户名，<code>ignoresPlayerLimit</code> 是忽略服务器人数限制，<code>ignoresPlayerLimit</code> 是可省略的。</p><p>只有 <code>server.properties</code> 配置文件中的 <code>white-list</code> 为 <code>true</code>，<code>whitelist.json</code> 中的白名单才会生效。</p><p>如果在服务器正在运行的时候修改了白名单的话，需要在服务器命令行中输入：</p><pre><code class="hljs"><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">whitelist.jsonwhitelist <span class="hljs-keyword">reload</span><br></code></pre></td></tr></table></figure></code></pre><p>重新加载白名单才会生效。</p><p>设置了白名单后就只有 <code>whitelist.json</code> 中的玩家才能进入服务器。</p><hr><p>那么到了这一步，服务器的服务端调整就全部做完了，接下来需要做的就是双击启动<strong>bedrock_server.exe</strong>，伴随着美妙的命令的跳动，程序显示:</p><pre><code class="hljs"><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[<span class="hljs-built_in">INFO</span>] opening worlds/Bedrock level/db<br>[<span class="hljs-built_in">INFO</span>] IPv4 supported, port: 19132<br>[<span class="hljs-built_in">INFO</span>]<span class="hljs-built_in"> IPv6 </span>supported, port: 19133<br>[<span class="hljs-built_in">INFO</span>] IPv4 supported, port: 62532<br>[<span class="hljs-built_in">INFO</span>]<span class="hljs-built_in"> IPv6 </span>supported, port: 62533<br>[<span class="hljs-built_in">INFO</span>]<span class="hljs-built_in"> Server </span>started.<br></code></pre></td></tr></table></figure></code></pre><p>我们需要记住第二行的“19132”，这是我们服务器的端口，在最后客户端连接服务器时需要输入。</p><hr><p>接下来，打开你的客户端我的世界，输入服务器ip、端口，然后连接服务器，顺便叫上你的小伙伴们一起玩吧，Enjoy~</p>]]></content>
    
    
    <categories>
      
      <category>图文教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我的世界</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
